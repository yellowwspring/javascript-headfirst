<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Равенства/Преобразования</title>
</head>
<body>
<h1>Оператор проверки равенства (также известный как ==) </h1>
<ul>
    <li>
        Если два значения относятся к одному типу, просто сравниваем их
    </li>
    <li>
        Если значения относятся к разным типам,
        пытаемся преобразовать их к одному типу, а потом сравниваем
    </li>
</ul>
<h3> Случаи преобразования:</h3>
<ul>
    <li>
        <p> случай №1: сравнение числа со строкой</p>
        При сравнении строки с числом всегда происходит одно и то же: строка преобразуется
        в число, после чего сравниваются два числа. Преобразование не всегда проходит гладко,
        потому что не все строки можно преобразовать в числа.
        <p>99 == "vanilla"  - false</p>
        <p>99 == NaN - false</p>
        <p> 99 == "99"  - true </p>

    </li>
    <li>
        <p> случай №2: Сравнение булевского значения с любым другим типом</p>
        В этом случае булевское значение преобразуется в число и два числа сравниваются. Выглядит
        немного странно, но происходящее становится более понятным, если просто запомнить, что
        true преобразуется в 1, а false преобразуется в 0. Также стоит помнить, что данная ситуация
        не всегда ограничивается одним преобразованием типа.
        <p>1 == true  - (true преобразуется в 1)</p>
        <p>1 == 1 - true</p>
        <p> если будем сравнивать булевое значение со строкой:</p>
        <p>"1" == true</p>
        <p>"1" == 1</p>
        <p>1 == 1 - true</p>
    </li>
    <li>
        <p>случай №3: сравнение null c undefined</p>
        Сравнение этих значений дает результат true. Выглядит немного странно,
        но таковы правила. Чтобы происходящее стало более понятным, эти значе-
        ния фактически представляют «отсутствие значения» (то есть переменная
        или объект, не имеющие значения), поэтому они считаются равными.
        <p> undefine == null   - true  </p>
    </li>



</ul>
<h1> Строгое неравенство / === / "тождественность"</h1>
<ul>
    <li>Два значения считаются строго равными только в том случае,
        если они относятся к одному типу и содержат одно значение
        <p> 42 === 42 - true</p>
        <p> "2hio" === "2hio"  - true</p>
        <p> false === false </p>
    </li>
</ul>
<h1> Преобразования : +, -, *, /</h1>
<ul>
    <li> СУММА:
    <p>При попытке сложения числа со строкой JavaScript преобразует число в строку
        и выполняет конкатенацию (поведение противоположно тому, что происходит
        при проверке равенства) </p>
    <p> let addi = 3 + "4";   ---> вернет 34  (а не 7)</p>
    </li>
    <li> УМНОЖЕНИЕ:
    <p>Что касается других арифметических операторов — умножения, деления и вычита-
        ния, — JavaScript рассматривает их как арифметические, а не строковые операции</p>
        <p> let multi = 3 * "4";   ---> 12</p>
        <p> let divi = 80 / "10";  ---> 8</p>
        <p> let minus = "10" - 5;  ---> 5</p>
    </li>
</ul>
<h1> Как проверить два объекта на равенство:</h1>
<ul>
    <li> При проверке 2 объектных переменных сравниваются ссылки на эти объекты
    <p> Две ссылки равны только в том случае, если они
        ссылаются на один объект</p>
        <p>if(var1 === var3) {// это один объект </p></li>
</ul>
<script>
    function findCarInLot(car) {
        for (var i = 0; i < lot.length; i++) {
            if (car === lot[i]) {
                return i;
            }
        }
        return -1;
    }
    let chevy = {
        make: "Chevy",
        model: "Bel Air"
    };
    let taxi = {
        make: "Webville Motors",
        model: "Taxi"
    };
    let fiat1 = {
        make: "Fiat",
        model: "500"
    };
    let fiat2 = {
        make: "Fiat",
        model: "500"
    };
    let lot = [chevy, taxi, fiat1, fiat2];
    let loc1 = findCarInLot(fiat2);
    let loc2 = findCarInLot(taxi);
    let loc3 = findCarInLot(chevy);
    let loc4 = findCarInLot(fiat1);
    console.log(loc1); // 3
    console.log(loc2); // 1
    console.log(loc3); // 0
    console.log(loc4); // 2
</script>

</body>
</html>